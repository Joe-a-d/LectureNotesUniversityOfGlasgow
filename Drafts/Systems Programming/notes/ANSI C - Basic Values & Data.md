# ANSI C - Basic Values & Data

## Abstract State Machine

> Keywords : abstract state machine , compiler optimisation,

C programs run in an *abstract state machine*, this has the advantage of being machine independent. How to translate between the actual value and its representation is the responsibility of the compiler, which means that often the compiler can (and will) perform certain substitutions in order to *optimise* the executable to a specific architecture. 
For example, not all intermediate operations and their values need to be observable to the user. **Unless they are stored in addressable memory, or need to be printed, the compiler is free to shortcut the intermediate results given that the end result is the same**

### Values

A **value** in C is an abstract entity that usually exists beyond your program. Think of the mathematical concept of numbers, regardless of their representation they all have certain properties and adhere to certain rules

> In C all values are numbers or translate to numbers

We can define the **data** generated by an executable as all this values grouped together. Lastly the **state** of a program is dependent on the following:

  - The executable
  - The point of execution
  - The data
  - Outside Intervention (e.g I/O)

It follows that a program which runs with the same data from the same execution point should return the same value. Furthermore, since we aim for C programs to not be platform dependent we must also make sure that the computations of our program are dependent on our specs and not on the platform which generated the executable. In order to achieve this, C uses types (recall from lecture 2 how meaning is preserved via types, i.e addin "0"+"1" = "01" ; 0+1=0)

### Types

> All values have a type which is statically determined and determines the result of all operations

Kernighan and Ritchie state that there are only 4 basic types:
    - `char` : a single byte capable of holding one character in the local character set
    - `int` : an integer, size is machine dependent
    - `float` : single-precision floating point
    - `double` : double-precision floating point

In addition to these basic types there exist *qualifiers* which can be applied to them and when they
are the type is usually omitted : `short, long, signed, unsigned` 

 > Use `unsigned` for small quantities that canâ€™t be negative.

 > Use `signed` for small quantities that bear a sign.

 > Use `ptrdiff_t` for large differences that bear a sign.

 > Use `double` for floating-point calculations.

 > Use `double complex` for complex calculations.




